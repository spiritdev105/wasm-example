use tari_template_macros::template;

#[template]
mod hello_world {
    // Not sure if deriving a trait like this would be compatible with our template macro
    #[derive(Default)]
    struct HelloWorld {}

    impl HelloWorld {
        pub fn greet() -> String {
            "Hello World!".to_string()
        }
    }
}

#[cfg(test)]
mod tests {
    
    // by default it assumes that the test is in the same Rust project as the template
    // if the template we want to test is in another project, we coould specify:
    //     #[template_stub(path = "../another_poject", module="HelloWorld")]
    #[template_stub(module="HelloWorld")]
    struct HelloWorld;

    #[test]
    fn greet_works() {
        // initialize the component
        let mut hello_world = HelloWorld::default();

        // the "HelloWorld" struct referenced in this test is a wrapper generated by the "template_stub" macro
        // so it will implement a "Component" trait with utility functions like "component_address()"
        println!("The component address is: {}", hello_world.component_address());

        // the "template_stub" macro generates a proxy function for each user-defined function in the template,
        // internally it builds and runs a transaction on the wasm engine for each function/method invocation
        assert_eq!(hello_world.greet(), Ok("Hello World!".to_string()));
    }
}
